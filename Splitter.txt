import React, { useState, useEffect, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
// Import Check icon for copy feedback
import { ThumbsUp, ThumbsDown, Share2, Clipboard, MoreVertical, RotateCcw, Pin, Edit, Trash2, Check } from 'lucide-react';
// Import v4 from uuid library
import { v4 as uuidv4 } from 'uuid';

// Helper function to conditionally join class names
const classNames = (...classes) => {
  return classes.filter(Boolean).join(' ');
};

// Tooltip Component (as provided by you) - No changes here, as it's a utility component
const Tooltip = ({ children, text }) => {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const targetRef = useRef(null);
  const tooltipRef = useRef(null);
  let showTimeout;
  let hideTimeout;

  const handleMouseEnter = () => {
    clearTimeout(hideTimeout);
    showTimeout = setTimeout(() => {
      setIsVisible(true);
    }, 50); // Appear almost instantly (50ms delay)
  };

  const handleMouseLeave = () => {
    clearTimeout(showTimeout);
    hideTimeout = setTimeout(() => {
      setIsVisible(false);
    }, 100); // Disappear quickly (100ms delay)
  };

  useEffect(() => {
    if (isVisible && targetRef.current && tooltipRef.current) {
      const targetRect = targetRef.current.getBoundingClientRect();
      const tooltipRect = tooltipRef.current.getBoundingClientRect();

      // Position the tooltip above the target element, centered horizontally
      const top = targetRect.top - tooltipRect.height - 8; // 8px padding above
      const left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);

      setPosition({ top: top, left: left });
    }
  }, [isVisible, text]);

  useEffect(() => {
    return () => {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
    };
  }, []);

  return (
    <div className="relative inline-block">
      {React.cloneElement(children, {
        ref: targetRef,
        onMouseEnter: handleMouseEnter,
        onMouseLeave: handleMouseLeave,
      })}
      {isVisible && (
        <div
          ref={tooltipRef}
          className="fixed z-50 px-3 py-1 bg-black text-white text-xs rounded-md shadow-lg whitespace-nowrap"
          style={{ top: position.top, left: position.left }}
        >
          {text}
        </div>
      )}
    </div>
  );
};

// ThinkingProcess Component for animated expand/collapse
const ThinkingProcess = ({ content, isOpen, onToggle }) => {
  const contentRef = useRef(null);
  const [maxHeight, setMaxHeight] = useState('0px');
  const [currentOpacity, setCurrentOpacity] = useState(0);

  useEffect(() => {
    console.log(`ThinkingProcess [${content.substring(0, Math.min(content.length, 20))}...]: isOpen prop changed to ${isOpen}`);
    if (contentRef.current) {
      if (isOpen) {
        requestAnimationFrame(() => {
          if (contentRef.current) {
            const scrollHeight = contentRef.current.scrollHeight;
            setMaxHeight(`${scrollHeight}px`);
            setCurrentOpacity(1);
            console.log(`ThinkingProcess [${content.substring(0, Math.min(content.length, 20))}...]: Setting maxHeight to ${scrollHeight}px (open)`);
          }
        });
      } else {
        setMaxHeight(`${contentRef.current.scrollHeight}px`);
        requestAnimationFrame(() => {
          if (contentRef.current) {
            setMaxHeight('0px');
            setCurrentOpacity(0);
            console.log(`ThinkingProcess [${content.substring(0, Math.min(content.length, 20))}...]: Setting maxHeight to 0px (close)`);
          }
        });
      }
    }
  }, [isOpen, content]);

  return (
    // Adjusted margin-top to bring it closer to the bot's icon
    <div className="mt-0 mb-0 flex items-center">
      <div className="group flex-grow">
        <button
          type="button"
          onClick={(e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log("DEBUG: 'Show thinking' button clicked inside ThinkingProcess!");
            onToggle();
          }}
          // Updated button styling: bg-white
          className="flex items-center cursor-pointer text-gray-700 font-medium bg-white rounded-full pl-4 pr-2 py-2 w-30 h-8 hover:bg-gray-200 transition-all duration-400 ease-in-out focus:outline-none z-0 relative"
        >
          <span className="flex items-center text-sm whitespace-nowrap">
            {/* Removed the thinking icon SVG */}
            Show thinking
          </span>
          <svg
            className={`w-4 h-4 text-gray-600 transform ${isOpen ? 'rotate-180' : ''} transition-transform duration-200 ml-2`}
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        </button>

        <div
          ref={contentRef}
          // Updated content styling: bg-white
          className="ml-4 mt-0 text-gray-700 font-inter text-base leading-relaxed bg-white p-1 overflow-hidden transition-all duration-500 ease-in-out border-l-2 border-gray-300 pl-6"
          style={{ maxHeight: maxHeight, opacity: currentOpacity }}
        >
          <div className="whitespace-pre-wrap">
            {content.split('\n').map((line, i) => {
              if (line.startsWith('Examining Debug Logs') || line.startsWith('Uncovering the Root Cause')) {
                return <p key={i} className="italic text-lg font-semibold mb-2">{line}</p>;
              }
              return <p key={i} className="mb-2">{line}</p>;
            })}
            {!content && <p>Thinking...</p>}
          </div>
        </div>
      </div>
    </div>
  );
};


// Main App component
const App = () => {
  // User ID (generated locally and persisted in localStorage)
  const [userId, setUserId] = useState(() => {
    const storedUserId = localStorage.getItem('chatbotUserId');
    if (storedUserId) {
      return storedUserId;
    }
    const newId = uuidv4(); // Changed from crypto.randomUUID()
    localStorage.setItem('chatbotUserId', newId);
    return newId;
  });

  // Chat states
  const [inputText, setInputText] = useState('');
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(true);
  const [isSidebarLockedOpen, setIsSidebarLockedOpen] = useState(false);
  const [messages, setMessages] = useState([]); // Messages now include isCopied, isLiked, isDisliked
  const [isLoading, setIsLoading] = useState(false); // For LLM response

  // Conversation history states
  const [conversations, setConversations] = useState([]); // List of { id, title, messages, isPinned }
  const [currentConversationId, setCurrentConversationId] = useState(null);
  const [currentConversationTitle, setCurrentConversationTitle] = useState('New Chat');
  const [isConversationsLoading, setIsConversationsLoading] = useState(true); // For loading conversations from backend

  // State for managing context menu (options dropdown)
  const [activeContextMenu, setActiveContextMenu] = useState(null); // Stores ID of conversation with active menu
  const contextMenuRef = useRef(null);

  // State for rename modal
  const [isRenameModalOpen, setIsRenameModalOpen] = useState(false);
  const [renameConversationId, setRenameConversationId] = useState(null);
  const [renameCurrentTitle, setRenameCurrentTitle] = useState('');
  const [renameNewTitle, setRenameNewTitle] = useState('');

  // New state to manage persistent visibility of action bar for feedback
  // This will now track if *any* thumbs feedback has been given on *any* message.
  // We'll rely on message.isLiked/isDisliked for individual message persistence.
  const [hasFeedbackBeenGiven, setHasFeedbackBeenGiven] = useState(false);


  const chatDisplayRef = useRef(null);

  // Base URL for your FastAPI backend
  const API_BASE_URL = "http://localhost:8000";

  // Effect to ensure userId is stored in localStorage
  useEffect(() => {
    if (userId) {
      localStorage.setItem('chatbotUserId', userId);
    }
  }, [userId]);

  // Close context menu when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (contextMenuRef.current && !contextMenuRef.current.contains(event.target)) {
        setActiveContextMenu(null);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // Function to sort conversations: pinned first, then by lastUpdated (desc)
  const sortConversations = (convs) => {
    return [...convs].sort((a, b) => {
      if (a.isPinned && !b.isPinned) return -1;
      if (!a.isPinned && b.isPinned) return 1;
      return new Date(b.lastUpdated) - new Date(a.lastUpdated);
    });
  };

  // Fetch conversations from backend on component mount and userId change
  useEffect(() => {
    const fetchConversations = async () => {
      setIsConversationsLoading(true);
      try {
        const response = await fetch(`${API_BASE_URL}/conversations/${userId}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        // Sort conversations only on initial fetch
        setConversations(sortConversations(data));

        // If no current conversation is set, load the most recent one if available
        if (!currentConversationId && data.length > 0) {
          loadConversation(data[0].id);
        } else if (!currentConversationId && data.length === 0) {
          // If no conversations exist, ensure it's a new chat state
          handleNewChat();
        }

      } catch (error) {
        console.error("Error fetching conversations:", error);
        // Optionally display an error message to the user
      } finally {
        setIsConversationsLoading(false);
      }
    };

    // Only fetch conversations if userId is available
    if (userId) {
      fetchConversations();
    }
  }, [userId]); // Re-fetch when userId changes (though it's stable now)

  // Auto-save conversation when messages or currentConversationId or currentConversationTitle change
  useEffect(() => {
    // Only save if there's a current conversation and messages exist
    if (currentConversationId && messages.length > 0) {
      console.log("App: messages state changed, attempting to save conversation.");
      // Debounce saving to prevent too many writes on rapid state updates (e.g., streaming)
      const handler = setTimeout(() => {
        // Find the current conversation's pinned status at the time of execution
        const currentConv = conversations.find(conv => conv.id === currentConversationId);
        const isCurrentPinned = currentConv ? currentConv.isPinned : false;
        const titleToSave = currentConversationTitle; // Use the current state value, which is now in dependency array
        console.log("DEBUG (App.jsx): Auto-saving conversation with title:", titleToSave, "and messages count:", messages.length, "for ID:", currentConversationId);
        // Pass false to shouldReSort here, as this useEffect is for general auto-saving, not explicit reordering
        saveConversation(currentConversationId, titleToSave, messages, isCurrentPinned, false); 
      }, 500); // Save after 500ms of no further message changes

      return () => {
        clearTimeout(handler);
      };
    }
  }, [messages, currentConversationId, currentConversationTitle]); // ADDED currentConversationTitle to dependencies

  // Handle input change
  const handleInputChange = (e) => {
    setInputText(e.target.value);
  };

  // Function to save or update a conversation in the backend
  const saveConversation = async (id, title, msgs, isPinned = false, shouldReSort = false) => {
    try {
      const conversationData = {
        id: id,
        user_id: userId,
        title: title,
        messages: msgs.map(msg => ({
          id: msg.id,
          sender: msg.sender,
          text: msg.text,
          thinkingContent: msg.thinkingContent || null,
          isThinkingOpen: msg.isThinkingOpen || false,
          // Ensure these new fields are included when saving
          isCopied: msg.isCopied || false,
          isLiked: msg.isLiked || false,
          isDisliked: msg.isDisliked || false,
        })),
        isPinned: isPinned, // Include isPinned status
        lastUpdated: new Date().toISOString() // ISO string for timestamp
      };

      console.log("DEBUG (App.jsx): Sending save request for ID:", id, "with title:", title, "and messages:", conversationData.messages.length);
      const response = await fetch(`${API_BASE_URL}/save_conversation`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(conversationData)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      console.log("Conversation saved successfully!");
      
      // Update the local conversations state without re-fetching all
      setConversations(prevConversations => {
        const existingIndex = prevConversations.findIndex(conv => conv.id === id);
        let updatedConvs;
        if (existingIndex > -1) {
          // Update existing conversation
          updatedConvs = prevConversations.map((conv, index) =>
            index === existingIndex ? { ...conv, title: title, lastUpdated: conversationData.lastUpdated, isPinned: isPinned } : conv
          );
        } else {
          // Add new conversation
          updatedConvs = [{ id, title, lastUpdated: conversationData.lastUpdated, isPinned, messages: [] }, ...prevConversations];
        }

        if (shouldReSort) {
          return sortConversations(updatedConvs);
        }
        return updatedConvs;
      });

    } catch (error) {
      console.error("Error saving conversation:", error);
      // Optionally display an error message to the user
    }
  };

  // Function to load a conversation from the backend or from local state
  const loadConversation = async (id) => {
    // Before loading a new conversation, save the current one if it exists and has messages
    if (currentConversationId && messages.length > 0 && currentConversationId !== id) {
      console.log("DEBUG (App.jsx): Saving current chat before loading new one. ID:", currentConversationId, "Title:", currentConversationTitle, "Messages count:", messages.length);
      const currentConv = conversations.find(conv => conv.id === currentConversationId);
      const isCurrentPinned = currentConv ? currentConv.isPinned : false;
      await saveConversation(currentConversationId, currentConversationTitle, messages, isCurrentPinned, false);
    }

    setIsLoading(true);
    setActiveContextMenu(null); // Close any open context menus
    setHasFeedbackBeenGiven(false); // Reset feedback state on conversation load

    // First, try to find the conversation in the already loaded 'conversations' state
    const existingConvInState = conversations.find(conv => conv.id === id);

    if (existingConvInState && existingConvInState.messages && existingConvInState.messages.length > 0) {
      // If found in state and has messages, use it directly
      console.log("DEBUG (App.jsx): Loading conversation from local state:", id, "with title:", existingConvInState.title, "and messages count:", existingConvInState.messages.length);
      setMessages(existingConvInState.messages.map(msg => ({
        id: msg.id || uuidv4(), // Changed from crypto.randomUUID()
        sender: msg.sender,
        text: msg.text,
        thinkingContent: msg.thinkingContent || null,
        isThinkingOpen: msg.isThinkingOpen || false,
        isCopied: msg.isCopied || false, // Initialize new fields
        isLiked: msg.isLiked || false,
        isDisliked: msg.isDisliked || false,
      })));
      setCurrentConversationId(existingConvInState.id);
      setCurrentConversationTitle(existingConvInState.title); // Set title from loaded state
      setIsLoading(false);
      
      // Check if any message in the loaded conversation has feedback to keep the bar visible
      const anyFeedback = existingConvInState.messages.some(msg => msg.isLiked || msg.isDisliked);
      setHasFeedbackBeenGiven(anyFeedback);

      return; // Exit early
    }

    // If not found in state or messages are missing, fetch from backend
    console.log("DEBUG (App.jsx): Fetching conversation from backend:", id);
    try {
      const response = await fetch(`${API_BASE_URL}/conversation/${userId}/${id}`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Ensure data.messages is an array, even if empty or null from backend
      console.log("DEBUG (App.jsx): Received messages from backend for ID:", id, "count:", (data.messages || []).length, "title:", data.title);
      const loadedMessages = (data.messages || []).map(msg => ({
        id: msg.id || uuidv4(), // Changed from crypto.randomUUID()
        sender: msg.sender,
        text: msg.text,
        thinkingContent: msg.thinkingContent || null,
        isThinkingOpen: msg.isThinkingOpen || false,
        isCopied: msg.isCopied || false, // Initialize new fields
        isLiked: msg.isLiked || false,
        isDisliked: msg.isDisliked || false,
      }));
      setMessages(loadedMessages);
      setCurrentConversationId(data.id);
      setCurrentConversationTitle(data.title); // Set title from fetched data

      // Check if any message in the fetched conversation has feedback
      const anyFeedback = loadedMessages.some(msg => msg.isLiked || msg.isDisliked);
      setHasFeedbackBeenGiven(anyFeedback);

    } catch (error) {
      console.error("Error loading conversation:", error);
      setMessages([]);
      setCurrentConversationId(null);
      setCurrentConversationTitle('New Chat');
      setHasFeedbackBeenGiven(false); // No feedback if conversation failed to load
    } finally {
      setIsLoading(false);
    }
  };

  // Handle new chat button click
  const handleNewChat = async () => {
    // If there's an active conversation with messages, save it before starting a new one
    // Only save if it's NOT the conversation being actively deleted.
    // The `handleDeleteConversation` will handle clearing state if it's the current one.
    if (currentConversationId && messages.length > 0) {
        const idToSave = currentConversationId;
        const titleToSave = currentConversationTitle;
        const currentConv = conversations.find(conv => conv.id === idToSave);
        const isCurrentPinned = currentConv ? currentConv.isPinned : false;

        console.log("DEBUG (App.jsx): Saving current chat before new chat. ID:", idToSave, "Title:", titleToSave, "Messages count:", messages.length);
        await saveConversation(idToSave, titleToSave, messages, isCurrentPinned, false); // Do not re-sort when starting new chat
    }

    setMessages([]);
    setInputText('');
    setCurrentConversationId(uuidv4()); // Changed from crypto.randomUUID()
    setCurrentConversationTitle('New Chat'); // Reset title for the new chat
    setActiveContextMenu(null); // Close any open context menus
    setHasFeedbackBeenGiven(false); // Reset feedback state on new chat
  };

  // Function to generate a title from the bot's response and user question using FastAPI
  const generateTitleWithBackend = async (userQuestion, botResponse) => {
    if ((!userQuestion || userQuestion.trim() === '') && (!botResponse || botResponse.trim() === '')) {
      return "Untitled Chat";
    }

    try {
      const response = await fetch(`${API_BASE_URL}/generate_title`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ user_question: userQuestion, response_text: botResponse })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      let generatedTitle = data.title.trim();

      // Capitalize the first character of the generated title
      if (generatedTitle.length > 0) {
        generatedTitle = generatedTitle.charAt(0).toUpperCase() + generatedTitle.slice(1);
      }

      // Limit to 50 characters to keep it concise for the sidebar
      return generatedTitle.substring(0, 50) + (generatedTitle.length > 50 ? '...' : '');
    } catch (error) {
      console.error("Error generating title with backend:", error);
      return "Untitled Chat";
    }
  };

  // Function to call FastAPI RAG API with streaming and <think> tag parsing
  const callFastAPIRagAPI = async (prompt) => {
    setIsLoading(true);

    let fullRawStreamedContent = ''; // Accumulates all content from the stream

    try {
      const payload = {
        question: prompt,
        user_id: userId,
        conversation_id: currentConversationId,
        conversation_title: currentConversationTitle,
        messages: messages // Send the current messages state to the backend
      };
      const apiUrl = `${API_BASE_URL}/chat`;

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let done = false;

      // Add a new empty bot message to the UI to stream into.
      // Assign a unique ID to the new bot message.
      const newBotMessageId = uuidv4(); // Changed from crypto.randomUUID()
      setMessages(prevMessages => [...prevMessages, {
        id: newBotMessageId,
        sender: 'bot',
        text: '',
        thinkingContent: '',
        isThinkingOpen: true,
        isCopied: false, // Initialize new fields
        isLiked: false,
        isDisliked: false,
      }]); // Initially open

      while (!done) {
        const { value, done: readerDone } = await reader.read();
        done = readerDone;
        const chunk = decoder.decode(value, { stream: true });

        if (chunk) {
          fullRawStreamedContent += chunk; // Accumulate all raw chunks

          // Regex to find content between <think> tags
          const thinkRegex = /<think>(.*?)<\/think>/s; // 's' flag for dotall (matches newlines)

          let extractedThinking = '';
          let mainAnswer = '';
          let shouldBeOpen = true; // Default to open while streaming

          const match = fullRawStreamedContent.match(thinkRegex);
          if (match) {
            extractedThinking = match[1].trim();
            mainAnswer = fullRawStreamedContent.replace(thinkRegex, '').trim();
            shouldBeOpen = false; // Close tab once </think> is found
          } else {
            // If <think> tag is present but not closed, content goes to thinking
            if (fullRawStreamedContent.includes('<think>')) {
                extractedThinking = fullRawStreamedContent.replace('<think>', '').trim();
                mainAnswer = ''; // Main answer is empty until </think> is found
                shouldBeOpen = true; // Keep tab open
            } else {
                // No <think> tag found yet, or it was never present, all content goes to main answer
                mainAnswer = fullRawStreamedContent.trim();
                shouldBeOpen = false; // Tab should be closed if no thinking or thinking is done
            }
          }

          // Update the specific bot message in the messages array using its ID
          setMessages(prevMessages => {
            const newMessages = [...prevMessages];
            const targetMessageIndex = newMessages.findIndex(msg => msg.id === newBotMessageId);

            if (targetMessageIndex !== -1 && newMessages[targetMessageIndex]?.sender === 'bot') {
                newMessages[targetMessageIndex].text = mainAnswer;
                newMessages[targetMessageIndex].thinkingContent = extractedThinking;
                newMessages[targetMessageIndex].isThinkingOpen = shouldBeOpen;
            }
            return newMessages;
          });
        }
      }

      // After streaming is complete, generate a new title based on the bot's final answer AND user question
      const finalBotResponseText = fullRawStreamedContent.replace(/<think>.*?<\/think>/s, '').trim();
      // Get the last user message from the *current* messages state, which should include the just-sent user message
      const lastUserMessage = messages[messages.length - 1]?.text || '';
      const newGeneratedTitle = await generateTitleWithBackend(lastUserMessage, finalBotResponseText);

      let titleToUseForSave = currentConversationTitle; // Default to current title
      // Only update the current conversation title if it's still the default "New Chat"
      // or if it's the substring of the first message (meaning it hasn't been properly titled yet).
      // This prevents overwriting a manually renamed title or a previously generated good title.
      if (currentConversationId &&
          (currentConversationTitle === 'New Chat' ||
           (messages.length > 0 && currentConversationTitle === messages[0].text.substring(0, Math.min(messages[0].text.length, 30)) + (messages[0].text.length > 30 ? '...' : ''))
          )
        ) {
        setCurrentConversationTitle(newGeneratedTitle);
        titleToUseForSave = newGeneratedTitle; // Use the new title for saving
      }

      // The useEffect for messages will now handle saving the conversation
      // after the bot's response has been fully streamed and the messages state updated.

      return finalBotResponseText;

    } catch (error) {
      console.error("Error calling FastAPI RAG API:", error);
      const errorMessage = "I apologize, but I encountered an error during streaming.";
      setMessages(prevMessages => {
        const newMessages = [...prevMessages];
        const lastBotMessageIndex = newMessages.length - 1; // Still target the last added bot message
        if (newMessages[lastBotMessageIndex]?.sender === 'bot') {
            newMessages[lastBotMessageIndex].text = errorMessage;
            newMessages[lastBotMessageIndex].thinkingContent = null; // Clear thinking on error
            newMessages[lastBotMessageIndex].isThinkingOpen = false; // Close thinking tab on error
        } else {
          newMessages.push({
            id: uuidv4(), // Changed from crypto.randomUUID()
            sender: 'bot',
            text: errorMessage,
            thinkingContent: null,
            isThinkingOpen: false,
            isCopied: false, // Initialize new fields
            isLiked: false,
            isDisliked: false,
          });
        }
        return newMessages;
      });
      return errorMessage;
    } finally {
      setIsLoading(false);
    }
  };

  // Handle sending message
  const handleSendMessage = async () => {
    if (inputText.trim() === '') return;

    // Generate a new conversation ID if it's a new chat
    const newConversationId = currentConversationId || uuidv4(); // Changed from crypto.randomUUID()
    setCurrentConversationId(newConversationId);

    const userMessage = {
      id: uuidv4(), // Changed from crypto.randomUUID()
      sender: 'user',
      text: inputText.trim(),
      isCopied: false, // Initialize for user messages too, though not strictly needed for UI
      isLiked: false,
      isDisliked: false,
    };
    const updatedMessages = [...messages, userMessage];
    setMessages(updatedMessages);
    setInputText('');

    // For the initial save, use the currentConversationTitle (which will be "New Chat" for a new conversation).
    // The actual AI-generated title will be set by callFastAPIRagAPI later.
    const titleForInitialSave = currentConversationTitle;
    
    // Get current pinned status if conversation already exists
    const currentConv = conversations.find(conv => conv.id === newConversationId);
    const isCurrentPinned = currentConv ? currentConv.isPinned : false;

    // Save the user message immediately. The title might be temporary for the first message.
    await saveConversation(newConversationId, titleForInitialSave, updatedMessages, isCurrentPinned, true); // Pass true to trigger re-sort

    // Call the RAG API and get the final cleaned response
    await callFastAPIRagAPI(userMessage.text);

    // The useEffect for messages will handle saving the conversation
    // after the bot's response has been fully streamed and the messages state updated.
  };

  useEffect(() => {
    if (!chatDisplayRef.current) return;
    chatDisplayRef.current.scrollTop = chatDisplayRef.current.scrollHeight;
  }, [inputText === '' && messages.length]);

  // New function to toggle the thinking tab for a specific message
  const toggleThinkingTab = (id) => {
    console.log(`DEBUG: toggleThinkingTab called for message ID: ${id}`);
    setMessages(prevMessages => {
      const newMessages = prevMessages.map(msg => {
        if (msg.id === id && msg.sender === 'bot') {
          const newState = !msg.isThinkingOpen;
          console.log(`DEBUG: Message ${id} isThinkingOpen set to: ${newState}`);
          return { ...msg, isThinkingOpen: newState };
        }
        return msg;
      });
      console.log("DEBUG: setMessages called within toggleThinkingTab.");
      return newMessages;
    });
  };

  // Function to handle "Reset Response" button click
  const handleResetResponse = async (messageId) => {
    console.log(`DEBUG: Resetting response for message ID: ${messageId}`);
    setIsLoading(true);

    // Find the original user message that triggered this bot response
    const messageIndex = messages.findIndex(msg => msg.id === messageId);
    if (messageIndex === -1 || messages[messageIndex].sender !== 'bot') {
      console.error("Could not find bot message to reset or it's not a bot message.");
      setIsLoading(false);
      return;
    }

    const previousUserMessage = messages[messageIndex - 1]; // Assuming user message is directly before bot's
    if (!previousUserMessage || previousUserMessage.sender !== 'user') {
      console.error("Could not find the preceding user message for reset.");
      setIsLoading(false);
      return;
    }

    // Remove the current bot message (and any subsequent messages if they exist, though they shouldn't in a linear chat)
    setMessages(prevMessages => {
      const newMessages = prevMessages.slice(0, messageIndex); // Keep messages up to the user's last message
      return newMessages;
    });

    // Re-call the RAG API with the last user message
    // The `useEffect` for messages will handle saving the conversation after the new response streams in.
    await callFastAPIRagAPI(previousUserMessage.text);
  };

  // Function to handle "Copy" button click with visual feedback
  const handleCopyResponse = (messageId, textToCopy) => {
    // Use document.execCommand('copy') for clipboard operations in iframes
    const textArea = document.createElement('textarea');
    textArea.value = textToCopy;
    textArea.style.position = 'fixed'; // Avoid scrolling to bottom
    textArea.style.left = '-9999px'; // Move off-screen
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
      const successful = document.execCommand('copy');
      if (successful) {
        console.log('Copied to clipboard!');
        // Update message state to show copied feedback
        setMessages(prevMessages => prevMessages.map(msg =>
          msg.id === messageId ? { ...msg, isCopied: true } : msg
        ));
        // Revert icon after 2 seconds
        setTimeout(() => {
          setMessages(prevMessages => prevMessages.map(msg =>
            msg.id === messageId ? { ...msg, isCopied: false } : msg
          ));
        }, 2000);
      } else {
        console.error('Failed to copy.');
      }
    } catch (err) {
      console.error('Oops, unable to copy', err);
    }
    document.body.removeChild(textArea);
  };

  // Function to handle "Thumbs Up" button click with visual feedback
  const handleThumbsUp = (messageId) => {
    setMessages(prevMessages => prevMessages.map(msg => {
      if (msg.id === messageId) {
        // Toggle liked status, and ensure disliked is false
        return { ...msg, isLiked: !msg.isLiked, isDisliked: false };
      }
      return msg;
    }));
    setHasFeedbackBeenGiven(true); // Set global flag that feedback has been given
    console.log(`DEBUG: Thumbs Up clicked for message ID: ${messageId}`);
    // You can send feedback to backend here if needed
  };

  // Function to handle "Thumbs Down" button click with visual feedback
  const handleThumbsDown = (messageId) => {
    setMessages(prevMessages => prevMessages.map(msg => {
      if (msg.id === messageId) {
        // Toggle disliked status, and ensure liked is false
        return { ...msg, isDisliked: !msg.isDisliked, isLiked: false };
      }
      return msg;
    }));
    setHasFeedbackBeenGiven(true); // Set global flag that feedback has been given
    console.log(`DEBUG: Thumbs Down clicked for message ID: ${messageId}`);
    // You can send feedback to backend here if needed
  };


  // Handle Enter key press for sending message
  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  // Handle Summarize Conversation feature (still uses Gemini API directly for simplicity)
  const handleSummarizeConversation = async () => {
    if (messages.length === 0) {
      setMessages((prevMessages) => [...prevMessages, { id: uuidv4(), sender: 'bot', text: "There's no conversation to summarize yet." }]); // Changed from crypto.randomUUID()
      return;
    }

    setIsLoading(true);
    const conversationText = messages.map(msg => `${msg.sender === 'user' ? 'You' : 'Bot'}: ${msg.text}`).join('\n');
    const prompt = `Please summarize the following conversation:\n\n${conversationText}`;

    try {
      let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
      const payload = { contents: chatHistory };
      const apiKey = ""; // API key will be provided by Canvas runtime
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

      const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
      });
      const result = await response.json();

      let summaryResponse = "Error: Could not get a summary from Gemini.";
      if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
          summaryResponse = result.candidates[0].content.parts[0].text;
      } else {
          console.error("Gemini API response structure unexpected for summary:", result);
      }

      setMessages((prevMessages) => [...prevMessages, {
        id: uuidv4(), // Changed from crypto.randomUUID()
        sender: 'bot',
        text: `✨ Summary: ${summaryResponse}`,
        isCopied: false,
        isLiked: false,
        isDisliked: false,
      }]);
    } catch (error) {
      console.error("Error calling Gemini API for summary:", error);
      setMessages((prevMessages) => [...prevMessages, {
        id: uuidv4(), // Changed from crypto.randomUUID()
        sender: 'bot',
        text: "Error: Failed to summarize conversation.",
        isCopied: false,
        isLiked: false,
        isDisliked: false,
      }]);
    } finally {
      setIsLoading(false);
    }
  };

  // Handle Rephrase Last Message feature (still uses Gemini API directly for simplicity)
  const handleRephraseLastMessage = async () => {
    const lastUserMessage = messages.slice().reverse().find(msg => msg.sender === 'user');

    if (!lastUserMessage) {
      setMessages((prevMessages) => [...prevMessages, { id: uuidv4(), sender: 'bot', text: "There's no user message to rephrase." }]); // Changed from crypto.randomUUID()
      return;
    }

    setIsLoading(true);
    const prompt = `Please rephrase the following sentence in a different way:\n\n"${lastUserMessage.text}"`;

    try {
      let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
      const payload = { contents: chatHistory };
      const apiKey = ""; // API key will be provided by Canvas runtime
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

      const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
      });
      const result = await response.json();

      let rephrasedResponse = "Error: Could not rephrase from Gemini.";
      if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
          rephrasedResponse = result.candidates[0].content.parts[0].text;
      } else {
          console.error("Gemini API response structure unexpected for rephrase:", result);
      }

      setMessages((prevMessages) => [...prevMessages, {
        id: uuidv4(), // Changed from crypto.randomUUID()
        sender: 'bot',
        text: `✨ Rephrased: ${rephrasedResponse}`,
        isCopied: false,
        isLiked: false,
        isDisliked: false,
      }]);
    } catch (error) {
      console.error("Error calling Gemini API for rephrase:", error);
      setMessages((prevMessages) => [...prevMessages, {
        id: uuidv4(), // Changed from crypto.randomUUID()
        sender: 'bot',
        text: "Error: Failed to rephrase message.",
        isCopied: false,
        isLiked: false,
        isDisliked: false,
      }]);
    } finally {
      setIsLoading(false);
    }
  };

  // Handle deleting a conversation
  const handleDeleteConversation = async (id) => {
    setActiveContextMenu(null); // Close context menu
    try {
      const response = await fetch(`${API_BASE_URL}/conversation/${userId}/${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      console.log("Conversation deleted successfully!");
      // Re-fetch conversations to update the sidebar
      const updatedConversationsResponse = await fetch(`${API_BASE_URL}/conversations/${userId}`);
      const updatedConversations = await updatedConversationsResponse.json();
      // Sort conversations: pinned first, then by lastUpdated (desc)
      const sortedData = updatedConversations.sort((a, b) => {
        if (a.isPinned && !b.isPinned) return -1;
        if (!a.isPinned && b.isPinned) return 1;
        return new Date(b.lastUpdated) - new Date(a.lastUpdated);
      });
      setConversations(sortedData);

      // If the deleted conversation was the current one, start a new chat
      if (currentConversationId === id) {
        handleNewChat();
      }
    } catch (error) {
      console.error("Error deleting conversation:", error);
      // Optionally display an error message
    }
  };

  // Handle renaming a conversation
  const handleRenameConversation = (convId, currentTitle) => {
    setActiveContextMenu(null); // Close context menu
    setRenameConversationId(convId);
    setRenameCurrentTitle(currentTitle);
    setRenameNewTitle(currentTitle); // Pre-fill with current title
    setIsRenameModalOpen(true);
  };

  const submitRename = async () => {
    if (!renameConversationId || renameNewTitle.trim() === '') return;

    try {
      const response = await fetch(`${API_BASE_URL}/rename_conversation`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_id: userId,
          conversation_id: renameConversationId,
          new_title: renameNewTitle.trim(),
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      console.log("Conversation renamed successfully!");

      // Update the current conversation title if it's the one being renamed
      if (currentConversationId === renameConversationId) {
        setCurrentConversationTitle(renameNewTitle.trim());
      }

      // Update the local conversations state without re-fetching all
      setConversations(prevConversations => {
        const updatedConvs = prevConversations.map(conv =>
          conv.id === renameConversationId ? { ...conv, title: renameNewTitle.trim() } : conv
        );
        // No re-sort needed here, as renaming doesn't change lastUpdated
        return updatedConvs;
      });

      setIsRenameModalOpen(false);
      setRenameConversationId(null);
      setRenameCurrentTitle('');
      setRenameNewTitle('');
    } catch (error) {
      console.error("Error renaming conversation:", error);
      // Optionally display an error message
    }
  };

  // Handle pinning/unpinning a conversation
  const handlePinConversation = async (convId, currentPinnedStatus) => {
    setActiveContextMenu(null); // Close context menu
    try {
      const response = await fetch(`${API_BASE_URL}/pin_conversation`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_id: userId,
          conversation_id: convId,
          is_pinned: !currentPinnedStatus, // Toggle the status
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      console.log("Conversation pin status updated successfully!");

      // Optimistically update the local state and then re-sort
      setConversations(prevConversations => {
          const updated = prevConversations.map(conv =>
              conv.id === convId ? { ...conv, isPinned: !currentPinnedStatus } : conv
          );
          return sortConversations(updated); // Re-sort after pin/unpin
      });

    } catch (error) {
      console.error("Error updating pin status:", error);
      // Optionally display an error message
    }
  };


  // --- Sidebar Interaction Logic ---
  const handleSidebarMouseEnter = () => {
    if (!isSidebarLockedOpen) {
      setIsSidebarCollapsed(false);
    }
  };

  const handleSidebarMouseLeave = () => {
    if (!isSidebarLockedOpen) {
      setIsSidebarCollapsed(true);
    }
  };

  const handleHamburgerClick = () => {
    const newLockedState = !isSidebarLockedOpen;
    setIsSidebarLockedOpen(newLockedState);

    if (newLockedState) {
        setIsSidebarCollapsed(false);
    } else {
        setIsSidebarCollapsed(true);
    }
  };

  // Separate pinned and unpinned conversations
  const pinnedConversations = conversations.filter(conv => conv.isPinned);
  const recentConversations = conversations.filter(conv => !conv.isPinned);


  return (
    <div className="flex h-screen bg-white font-inter">
      {/* Add custom CSS for the pulsing animation and running circle */}
      <style>
        {`
        @keyframes pulse-animation {
          0% {
            transform: scale(1);
            opacity: 1;
          }
          50% {
            transform: scale(1.1);
            opacity: 0.8;
          }
          100% {
            transform: scale(1);
            opacity: 1;
          }
        }

        .animate-pulse-bot {
          animation: pulse-animation 1.5s infinite ease-in-out;
        }

        @keyframes running-line-circle {
          0% {
            stroke-dashoffset: 0;
          }
          100% {
            stroke-dashoffset: -88; /* Circumference of r=14 circle is approx 88 */
          }
        }

        .animate-running-line-circle {
          animation: running-line-circle 1.5s linear infinite;
        }
        `}
      </style>

      {/* Sidebar */}
      <div
        // Changed sidebar background to light gray (bg-gray-50)
        className={`flex flex-col ${
          isSidebarCollapsed ? 'w-16' : 'w-64'
        } bg-gray-50 border-r border-gray-200 p-4 shadow-sm transition-all duration-300 ease-in-out`}
        onMouseEnter={handleSidebarMouseEnter}
        onMouseLeave={handleSidebarMouseLeave}
      >
        {/* Hamburger menu icon */}
        <div className="flex items-center mb-6">
          <button
            type="button"
            className="p-2 rounded-full hover:bg-gray-100 focus:outline-none"
            onClick={handleHamburgerClick}
            title="Toggle Sidebar"
          >
            <svg
              className="w-6 h-6 text-gray-700"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                d="M4 6h16M4 12h16M4 18h16"
              ></path>
            </svg>
          </button>
        </div>

        {/* New chat button */}
        <button
          type="button"
          className={`flex items-center rounded-full bg-blue-50 text-blue-700 font-medium mb-10 focus:outline-none
            transition-all duration-300 my-1 hover:bg-blue-100
            ${isSidebarCollapsed ? 'w-10 h-10 p-2' : 'w-full pl-2 pr-4 py-2'}
          `}
          onClick={handleNewChat}
          title="Start a new conversation"
        >
          <svg
            className="flex-shrink-0 w-6 h-6 text-blue-700"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d="M12 6v6m0 0v6m0-6h6m-6 0H6"
            ></path>
          </svg>
          <span className={`whitespace-nowrap text-sm transition-all duration-300 ${isSidebarCollapsed ? 'opacity-0 w-0 ml-0' : 'opacity-100 w-auto ml-2'}`}>
            New chat
          </span>
        </button>

        {/* Pinned Conversations List */}
        {/* Adjusted mt-2 to bring it closer to the New chat button */}
        <div className={`mt-2 transition-all duration-300 ${isSidebarCollapsed ? 'max-h-0 opacity-0 overflow-hidden' : 'max-h-full opacity-100'}`}>
          {pinnedConversations.length > 0 && (
            <>
              <h3 className={`text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2 transition-all duration-300 ${isSidebarCollapsed ? 'opacity-0 max-h-0' : 'opacity-100 max-h-full'}`}>
                Pinned
              </h3>
              {/* Increased mb-6 for more distance between Pinned and Recent */}
              <ul className="space-y-1 mb-6">
                {pinnedConversations.map((conv) => (
                  <li key={conv.id} className="flex items-center justify-between group relative">
                    <button
                      type="button"
                      className={`flex-grow text-left py-2 px-3 rounded-lg text-sm truncate
                        ${currentConversationId === conv.id ? 'bg-blue-100 text-blue-800 font-semibold' : 'hover:bg-gray-100 text-gray-700'}
                        focus:outline-none`}
                      onClick={() => loadConversation(conv.id)}
                      title={`Load conversation: ${conv.title}`}
                    >
                      <Pin className="w-3 h-3 inline-block mr-1 text-gray-500" />
                      {conv.title}
                    </button>
                    <button
                      type="button"
                      className="ml-2 p-1 rounded-full hover:bg-gray-200 text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity focus:outline-none"
                      onClick={(e) => {
                        e.stopPropagation(); // Prevent loading conversation
                        setActiveContextMenu(activeContextMenu === conv.id ? null : conv.id);
                      }}
                      title="Conversation Options"
                    >
                      <MoreVertical className="w-4 h-4" />
                    </button>

                    {activeContextMenu === conv.id && (
                      <div
                        ref={contextMenuRef}
                        className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-20 border border-gray-200"
                      >
                        <button
                          className="flex items-center w-full px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                          onClick={() => handlePinConversation(conv.id, conv.isPinned)}
                        >
                          <Pin className="w-4 h-4 mr-2" /> {conv.isPinned ? 'Unpin' : 'Pin'}
                        </button>
                        <button
                          className="flex items-center w-full px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                          onClick={() => handleRenameConversation(conv.id, conv.title)}
                        >
                          <Edit className="w-4 h-4 mr-2" /> Rename
                        </button>
                        <button
                          className="flex items-center w-full px-4 py-2 text-sm text-red-600 hover:bg-red-50"
                          onClick={() => handleDeleteConversation(conv.id)}
                        >
                          <Trash2 className="w-4 h-4 mr-2" /> Delete
                        </button>
                      </div>
                    )}
                  </li>
                ))}
              </ul>
            </>
          )}

          {/* Recent Conversations List */}
          {/* Removed mt-4 from this h3 to rely on the mb-6 from the Pinned section's ul */}
          <h3 className={`text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2 transition-all duration-300 ${isSidebarCollapsed ? 'opacity-0 max-h-0' : 'opacity-100 max-h-full'}`}>
            Recent
          </h3>
          {isConversationsLoading ? (
            <div className="text-gray-500 text-sm">Loading conversations...</div>
          ) : recentConversations.length === 0 ? (
            <div className="text-gray-500 text-sm">No recent chats.</div>
          ) : (
            <ul className="space-y-1">
              {recentConversations.map((conv) => (
                <li key={conv.id} className="flex items-center justify-between group relative">
                  <button
                    type="button"
                    className={`flex-grow text-left py-2 px-3 rounded-lg text-sm truncate
                      ${currentConversationId === conv.id ? 'bg-blue-100 text-blue-800 font-semibold' : 'hover:bg-gray-100 text-gray-700'}
                      focus:outline-none`}
                    onClick={() => loadConversation(conv.id)}
                    title={`Load conversation: ${conv.title}`}
                  >
                    {conv.title}
                  </button>
                  <button
                    type="button"
                    className="ml-2 p-1 rounded-full hover:bg-gray-200 text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity focus:outline-none"
                    onClick={(e) => {
                      e.stopPropagation(); // Prevent loading conversation
                      setActiveContextMenu(activeContextMenu === conv.id ? null : conv.id);
                    }}
                    title="Conversation Options"
                  >
                    <MoreVertical className="w-4 h-4" />
                  </button>

                  {activeContextMenu === conv.id && (
                    <div
                      ref={contextMenuRef}
                      className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-20 border border-gray-200"
                    >
                      <button
                        className="flex items-center w-full px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                        onClick={() => handlePinConversation(conv.id, conv.isPinned)}
                        >
                          <Pin className="w-4 h-4 mr-2" /> {conv.isPinned ? 'Unpin' : 'Pin'}
                        </button>
                        <button
                          className="flex items-center w-full px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                          onClick={() => handleRenameConversation(conv.id, conv.title)}
                          >
                            <Edit className="w-4 h-4 mr-2" /> Rename
                          </button>
                          <button
                            className="flex items-center w-full px-4 py-2 text-sm text-red-600 hover:bg-red-50"
                            onClick={() => handleDeleteConversation(conv.id)}
                            >
                              <Trash2 className="w-4 h-4 mr-2" /> Delete
                            </button>
                          </div>
                        )}
                      </li>
                    ))}
                  </ul>
                )}
              </div>
        
        
              {/* Settings button */}
              <button
                type="button"
                className={`flex items-center rounded-full bg-transparent hover:bg-gray-100 text-gray-700 font-medium mt-auto focus:outline-none
            transition-all duration-300 my-1
            ${isSidebarCollapsed ? 'w-10 h-10 p-2' : 'w-full pl-2 pr-4 py-2'}
          `}
          title="Open Settings"
        >
          <svg
            className="w-6 h-6 text-gray-700"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.564.342 1.25.21 1.724-1.065z"
            ></path>
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
            ></path>
          </svg>
          <span className={`whitespace-nowrap text-sm transition-all duration-300 ${isSidebarCollapsed ? 'opacity-0 w-0 ml-0' : 'opacity-100 w-auto ml-2'}`}>
              Settings
            </span>
        </button>
      </div>

      {/* Main content area */}
      <div className="flex flex-col flex-grow relative bg-white"> {/* Main content background is now white */}
        {/* Top header bar for main content */}
        <div className="absolute top-0 left-0 right-0 p-4 flex items-center justify-between bg-white border-b border-white z-10 shadow-sm"> {/* Changed border-white */}
          {/* Gemini logo and model selector */}
          <div className="flex items-center">
            <span className="text-xl font-inter text-gray-600">HAN</span>
            {/* Removed the model selection dropdown */}
          </div>
          {/* Upgrade button and user avatar */}
          <div className="flex items-center space-x-4">
            {/* Removed the Upgrade button */}
            <div className="w-8 h-8 rounded-full bg-blue-700 flex items-center justify-center text-white font-bold text-sm" title="User Profile">
              N
            </div>
          </div>
        </div>

        {/* Chat display area */}
        <div ref={chatDisplayRef} className={`flex-grow flex flex-col items-center px-4 overflow-y-auto pt-24 scroll-smooth ${messages.length === 0 ? 'justify-center' : ''}`}>
          {messages.length === 0 ? (
            <div className="text-4xl font-light text-blue-600">Hello, _</div>
          ) : (
            <div className="w-full max-w-3xl">
              {messages.map((message) => (
                <div
                  key={message.id}
                  className={classNames(
                    "flex mb-4",
                    "items-start",
                    "group",
                    message.sender === 'user' ? "justify-end" : "justify-start"
                  )}
                >
                  {/* Bot icon and running circle animation */}
                  {message.sender === 'bot' && (
                    <div className={classNames(
                      "relative flex-shrink-0 w-8 h-8 rounded-full bg-white flex items-center justify-center text-white text-lg mr-2 ml-2 overflow-hidden",
                      isLoading && "animate-pulse-bot" // Apply pulse animation to the icon container
                    )}>
                      {/* Running line circle SVG */}
                      {isLoading && (
                        <svg className="absolute inset-0 w-full h-full" viewBox="0 0 32 32">
                          <circle
                            cx="16" cy="16" r="14" // Center and radius, slightly smaller to fit within 32x32
                            fill="none"
                            stroke="#3B82F6" // Light blue from bot icon
                            strokeWidth="2"
                            strokeDasharray="20 68" /* Dash length 20, gap 68 (circumference 2*pi*r approx 88) */
                            strokeDashoffset="0"
                            className="animate-running-line-circle"
                          />
                        </svg>
                      )}
                      {/* Original Bot icon SVG */}
                      <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" fill="white" className="w-8 h-8 z-10">
                        <path d="M22 0c0 16.9-9.1 32-22 32c12.9 0 22 15.1 22 32c0-16.9 9.1-32 22-32c-12.9 0-22-15.1-22-32" fill="#3B82F6" /> {/* light blue */}
                        <path d="M53 0c0 8.4-4.6 16-11 16c6.4 0 11 7.6 11 16c0-8.4 4.6-16 11-16c-6.4 0-11-7.6-11-16" fill="#2563EB" /> {/* medium blue */}
                        <path d="M48 32c0 8.4-4.6 16-11 16c6.4 0 11 7.6 11 16c0-8.4 4.6-16 11-16c-6.4 0-11-7.6-11-16" fill="#1D4ED8" /> {/* dark blue */}
                      </svg>
                    </div>
                  )}

                  {/* Message content */}
                  <div className="flex flex-col space-y-2">
                    {/* Thinking Process */}
                    {message.sender === 'bot' && (
                      <>
                        {!message.thinkingContent && (
                          <div className="text-sm text-gray-400 italic animate-pulse mt-2 ml-2">Just one second...</div>
                        )}
                        {message.thinkingContent && (
                          <ThinkingProcess
                            content={message.thinkingContent}
                            isOpen={message.isThinkingOpen}
                            onToggle={() => toggleThinkingTab(message.id)}
                          />
                        )}
                      </>
                    )}
                    {/* Message bubble */}
                    <div
                      className={classNames(
                        message.sender === 'user'
                          ? "bg-blue-600 text-white rounded-xl py-2 px-3"
                          : "bg-white text-gray-800 rounded-xl ml-4"
                      )}
                    >
                      <div className="text-base leading-relaxed mt-0 break-words whitespace-pre-wrap break-all">
                        {message.sender === 'bot' ? (
                          <ReactMarkdown>{message.text}</ReactMarkdown>
                        ) : (
                          message.text
                        )}
                      </div>

                      {/* Bot actions */}
                      {message.sender === 'bot' && !isLoading && message.text.length > 0 && (
                        <div className={classNames(
                          "flex space-x-3 mt-2 text-gray-500 text-sm transition-opacity duration-200",
                          (message.isLiked || message.isDisliked) ? "opacity-100" : "opacity-0 group-hover:opacity-100"
                        )}>
                          <button
                            className={classNames(
                              "p-1 rounded-full hover:bg-gray-100",
                              message.isLiked ? "text-blue-500" : "text-gray-500"
                            )}
                            title="Like"
                            onClick={() => handleThumbsUp(message.id)}
                          >
                            <ThumbsUp className="w-3 h-3" fill={message.isLiked ? "currentColor" : "none"} />
                          </button>
                          <button
                            className={classNames(
                              "p-1 rounded-full hover:bg-gray-100",
                              message.isDisliked ? "text-red-500" : "text-gray-500"
                            )}
                            title="Dislike"
                            onClick={() => handleThumbsDown(message.id)}
                          >
                            <ThumbsDown className="w-3 h-3" fill={message.isDisliked ? "currentColor" : "none"} />
                          </button>
                          <button
                            className="p-1 rounded-full hover:bg-gray-100"
                            title="Copy"
                            onClick={() => handleCopyResponse(message.id, message.text)}
                          >
                            {message.isCopied ? <Check className="w-3 h-3" /> : <Clipboard className="w-3 h-3" />}
                          </button>
                          <button className="p-1 rounded-full hover:bg-gray-100" title="Reset Response" onClick={() => handleResetResponse(message.id)}>
                            <RotateCcw className="w-3 h-3" />
                          </button>
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              ))}
              {isLoading && messages[messages.length - 1]?.sender !== 'bot' && (
                <div className="flex justify-start mb-4 items-start group">
                  <div className={classNames(
                    "relative flex-shrink-0 w-8 h-8 rounded-full bg-white flex items-center justify-center text-white text-lg mr-2 ml-2 overflow-hidden",
                    isLoading && "animate-pulse-bot" // Apply pulse animation to the icon container
                  )}>
                    {/* Running line circle SVG */}
                    {isLoading && (
                      <svg className="absolute inset-0 w-full h-full" viewBox="0 0 32 32">
                        <circle
                          cx="16" cy="16" r="14"
                          fill="none"
                          stroke="#3B82F6"
                          strokeWidth="2"
                          strokeDasharray="20 68"
                          strokeDashoffset="0"
                          className="animate-running-line-circle"
                        />
                      </svg>
                    )}
                    {/* Original Bot icon SVG */}
                    <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" fill="white" className="w-8 h-8 z-10">
                      <path d="M22 0c0 16.9-9.1 32-22 32c12.9 0 22 15.1 22 32c0-16.9 9.1-32 22-32c-12.9 0-22-15.1-22-32" fill="#3B82F6" /> {/* light blue */}
                      <path d="M53 0c0 8.4-4.6 16-11 16c6.4 0 11 7.6 11 16c0-8.4 4.6-16 11-16c-6.4 0-11-7.6-11-16" fill="#2563EB" /> {/* medium blue */}
                      <path d="M48 32c0 8.4-4.6 16-11 16c6.4 0 11 7.6 11 16c0-8.4 4.6-16 11-16c-6.4 0-11-7.6-11-16" fill="#1D4ED8" /> {/* dark blue */}
                    </svg>
                  </div>
                  <div className="text-sm text-gray-400 italic animate-pulse mt-2 ml-2">Background processing...</div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Input bar at the bottom */}
        <div className="w-full max-w-3xl mx-auto px-0 pb-8">
          <div className="flex flex-col items-center bg-white border border-gray-200 rounded-2xl shadow-lg px-4 py-3">
            <div className="flex items-center w-full">
              {/* Plus icon for attachments */}
              {/* <button
                type="button"
                className="p-2 rounded-full hover:bg-gray-100 text-gray-600 focus:outline-none"
                title="Attach files"
              >
                <svg
                  className="w-6 h-6"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M12 6v6m0 0v6m0-6h6m-6 0H6"
                  ></path>
                </svg>
              </button> */}

              {/* Input text area */}
              <textarea
                className="flex-grow mx-3 p-2 bg-transparent resize-none outline-none text-gray-800 placeholder-gray-500 text-base"
                rows="1"
                placeholder="Ask me anything"
                value={inputText}
                onChange={handleInputChange}
                onKeyPress={handleKeyPress}
                style={{ minHeight: '24px', maxHeight: '120px' }}
              ></textarea>

              {/* Action icons */}
              <div className="flex items-center space-x-2">
                {/* Deep Research Button */}
                {/* <Tooltip text="Deep Research">
                  <button
                    type="button"
                    className="p-2 rounded-full hover:bg-gray-100 text-gray-600 focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={isLoading}
                    title="Deep Research"
                  >
                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                  </button>
                </Tooltip> */}

                {/* Canvas Button */}
                {/* <Tooltip text="Canvas">
                  <button
                    type="button"
                    className="p-2 rounded-full hover:bg-gray-100 text-gray-600 focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={isLoading}
                    title="Canvas"
                  >
                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                  </button>
                </Tooltip> */}

                {/* Image Button */}
                {/* <Tooltip text="Image">
                  <button
                    type="button"
                    className="p-2 rounded-full hover:bg-gray-100 text-gray-600 focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={isLoading}
                    title="Image"
                  >
                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                  </button>
                </Tooltip> */}

                {/* Microphone Button */}
                {/* <Tooltip text="Microphone">
                  <button
                    type="button"
                    className="p-2 rounded-full hover:bg-gray-100 text-gray-600 focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={isLoading}
                    title="Microphone"
                  >
                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 11a7 7 0 01-14 0v-1a7 7 0 0114 0v1z"></path><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 20v-4m-4 4h8"></path></svg>
                  </button>
                </Tooltip> */}

                {/* Send button */}
                <button
                  type="button"
                  className="p-2 rounded-full bg-blue-500 text-white hover:bg-blue-600 focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed"
                  onClick={handleSendMessage}
                  disabled={isLoading || inputText.trim() === ''}
                  title="Send Message"
                >
                  <svg
                    className="w-6 h-6"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M14 5l7 7m0 0l-7 7m7-7H3"
                    ></path>
                  </svg>
                </button>
              </div>
            </div>
            {/* Removed the disclaimer text */}
          </div>
        </div>

        {/* Display User ID (for debugging/multi-user identification) */}
        {userId && (
          <div className="absolute bottom-2 left-4 text-xs text-gray-400">
            User ID: {userId}
          </div>
        )}
      </div>

      {/* Rename Modal */}
      {isRenameModalOpen && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg shadow-xl w-96">
            <h2 className="text-lg font-semibold mb-4">Rename Conversation</h2>
            <p className="text-sm text-gray-600 mb-2">Current Title: <span className="font-medium">{renameCurrentTitle}</span></p>
            <input
              type="text"
              className="w-full p-2 border border-gray-300 rounded-md mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={renameNewTitle}
              onChange={(e) => setRenameNewTitle(e.target.value)}
              onKeyPress={(e) => {
                if (e.key === 'Enter') {
                  submitRename();
                }
              }}
              placeholder="Enter new title"
            />
            <div className="flex justify-end space-x-3">
              <button
                className="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 focus:outline-none"
                onClick={() => setIsRenameModalOpen(false)}
              >
                Cancel
              </button>
              <button
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed"
                onClick={submitRename}
                disabled={renameNewTitle.trim() === '' || renameNewTitle.trim() === renameCurrentTitle}
              >
                Rename
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default App;
