import pandas as pd
import plotly.graph_objects as go
import plotly.express as px # Still useful for initial data prep (melting)
import plotly.io as pio

# --- 1. CONFIGURATION & TEMPLATE ---
pio.templates.default = "plotly_white"

COLOR_PALETTE = {
    'Word Accuracy': 'rgba(100, 100, 250, 0.9)',
    'Phrase Accuracy': 'rgba(130, 70, 230, 0.9)',
    'Character Accuracy': 'rgba(70, 50, 200, 0.9)'
}
# Define lighter and darker shades for a pseudo-gradient/shadow
COLOR_SHADOWS = {
    'Word Accuracy': 'rgba(80, 80, 200, 0.7)',
    'Phrase Accuracy': 'rgba(110, 50, 200, 0.7)',
    'Character Accuracy': 'rgba(50, 30, 150, 0.7)'
}

# --- 2. DATA LOADING & CLEANING (Your Data) ---
# ... (Same as your previous code) ...
data = {
    'Tc': ['A', 'A', 'B', 'B', 'A', 'B', 'A', 'B', 'C', 'C'],
    'subtc': ['X', 'Y', 'Z', 'y', 'X', 'Z', 'Y', 'y', 'P', 'Q'],
    'utt': [1066, 1066, 108, 108, 500, 200, 400, 300, 150, 250],
    'word acc': ['12', '43', '85', '74', '15', '90', '40', '70', '60', '55'],
    'phrase acc': ['12', '21', '09', '92', '10', '11', '25', '95', '70', '65'],
    'character acc': ['12', '54', '12', '12', '10', '15', '50', '15', '80', '75']
}
df = pd.DataFrame(data)
df.columns = ['Tc', 'subtc', 'utt', 'word_acc', 'phrase_acc', 'character_acc']
acc_cols = ['word_acc', 'phrase_acc', 'character_acc']
for col in acc_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0).astype(int)

df_long = pd.melt(
    df,
    id_vars=['Tc', 'subtc', 'utt'],
    value_vars=acc_cols,
    var_name='Metric',
    value_name='Accuracy'
)
metric_order = ['Word Accuracy', 'Phrase Accuracy', 'Character Accuracy']
df_long['Metric'] = df_long['Metric'].str.replace('_acc', '').str.replace('_', ' ').str.title()
df_long['Metric'] = pd.Categorical(df_long['Metric'], categories=metric_order, ordered=True)
df_long = df_long.sort_values(by=['Tc', 'subtc', 'Metric'])


# --- 3. PLOTLY CHART CREATION (Manual Shape Drawing for Bars) ---

# Create a figure with subplots (faceting) first
# This uses make_subplots to set up the grid for Tc categories
num_tc = df_long['Tc'].nunique()
tc_categories = df_long['Tc'].unique()

fig = pio.make_subplots(
    rows=1, cols=num_tc,
    shared_yaxes=True,
    subplot_titles=[f"{tc}" for tc in tc_categories],
    horizontal_spacing=0.05 # Adjust space between subplots
)

# Define common bar properties
bar_width_factor = 0.25 # Adjust this to control bar width relative to category space
bar_corner_radius = 6   # Controls how rounded the corners are

# Iterate through each Tc category (subplot)
for i, tc in enumerate(tc_categories):
    df_tc = df_long[df_long['Tc'] == tc]
    
    # Create an invisible go.Bar for automatic axis scaling and hover information
    # This bar will be transparent and only serve for data representation and hover
    invisible_bar_trace = go.Bar(
        x=df_tc['subtc'],
        y=df_tc['Accuracy'],
        name='_invisible', # Name it as invisible to not show in legend
        showlegend=False,
        marker_color='rgba(0,0,0,0)', # Completely transparent
        marker_line_width=0,
        hovertemplate=(
            '<b>Test Case (Tc):</b> ' + tc + '<br>' +
            '<b>Sub-Tc:</b> %{x}<br>' +                     
            '<b>%{fullData.name} Accuracy:</b> %{y:.1f}%%' + 
            '<extra></extra>' 
        )
    )
    fig.add_trace(invisible_bar_trace, row=1, col=i+1)

    # Get unique subtc categories for current facet
    subtc_categories = df_tc['subtc'].unique()
    
    # Iterate through each subtc and Metric to draw custom shapes
    for j, subtc in enumerate(subtc_categories):
        df_subtc = df_tc[df_tc['subtc'] == subtc]
        
        # Determine the x-position for the group of bars within the subtc
        # The x-axis for each subplot starts from 0 for its categories.
        # Plotly internally maps categories to numerical positions.
        # For 'go.Layout.Shape', x0 and x1 are in 'xaxis' coordinate system.
        # We need to map category index to coordinate system.
        
        # A rough way to estimate x-positions for shapes (might need fine-tuning)
        # This assumes equal spacing of categories.
        x_center_subtc = j # category index
        
        num_metrics = len(metric_order)
        # Calculate width of a single bar and total group width
        group_width = bar_width_factor * (num_metrics + (num_metrics - 1) * 0.1) # approx
        bar_visual_width = bar_width_factor / num_metrics / 1.5 # Adjust as needed
        
        # Calculate starting point for the first bar in the group
        x_start_group = x_center_subtc - (group_width / 2.0)
        
        for k, metric in enumerate(metric_order):
            accuracy_row = df_subtc[df_subtc['Metric'] == metric]
            if not accuracy_row.empty:
                accuracy_value = accuracy_row['Accuracy'].iloc[0]
                
                # Calculate x-position for this specific bar
                x0_bar = x_start_group + k * bar_visual_width
                x1_bar = x0_bar + bar_visual_width
                
                main_color = COLOR_PALETTE.get(metric, 'grey')
                shadow_color = COLOR_SHADOWS.get(metric, 'darkgrey')

                # Add a subtle "shadow" shape slightly offset and darker
                fig.add_shape(
                    type="rect",
                    xref=f"x{i+1}", yref=f"y{i+1}",
                    x0=x0_bar + 0.01, x1=x1_bar + 0.01, # Offset x and y for shadow effect
                    y0=0.0, y1=accuracy_value - 1, # Make shadow slightly shorter for effect
                    fillcolor=shadow_color,
                    line=dict(width=0),
                    layer="below",
                    row=1, col=i+1
                )
                
                # Add the main bar shape with rounded corners
                fig.add_shape(
                    type="rect",
                    xref=f"x{i+1}", yref=f"y{i+1}",
                    x0=x0_bar, x1=x1_bar,
                    y0=0.0, y1=accuracy_value,
                    fillcolor=main_color,
                    line=dict(color='rgba(0,0,0,0.1)', width=0.5), # Subtle border
                    layer="above", # Ensure bars are on top of shadows
                    row=1, col=i+1,
                    # Rounded corners are hard for rect. You need to use 'path' or image.
                    # As a workaround for rounded top, we might add a tiny circle.
                    # A better way for rounded rects: set `path` directly if possible, or use Dash components.
                )
                
                # To simulate rounded top, we can add a small oval shape on top of each bar
                # This is a hacky way and might need precise tuning.
                fig.add_shape(
                    type="rect", # Using rect with border-radius property in CSS context
                                # but Plotly 'rect' shape does not have direct border-radius
                                # So, a path or another library would be better for perfect rounded caps.
                                # For this example, let's omit the exact rounded top due to complexity.
                                # The fillcolor will be the same as the bar
                    xref=f"x{i+1}", yref=f"y{i+1}",
                    x0=x0_bar, x1=x1_bar,
                    y0=accuracy_value - (accuracy_value * 0.05), # Slightly below the top
                    y1=accuracy_value,
                    fillcolor=main_color,
                    line=dict(color='rgba(0,0,0,0.1)', width=0.5),
                    layer="above",
                    # Rounded corners are done via 'border-radius' in CSS.
                    # Plotly shapes do not have a direct 'border-radius' property.
                    # Using path for a custom shape:
                    # 'path': f'M{x0_bar},{accuracy_value} L{x0_bar},{accuracy_value-radius} Q{x0_bar},{accuracy_value-radius} {x0_bar+radius},{accuracy_value-radius} L{x1_bar-radius},{accuracy_value-radius} Q{x1_bar},{accuracy_value-radius} {x1_bar},{accuracy_value} Z'
                    # This path string would be very complicated to generate dynamically for each bar.
                    # So, we'll keep simple rects for main body and accept non-rounded for now.
                )
                
                # Add text label (requires precise positioning)
                fig.add_annotation(
                    xref=f"x{i+1}", yref=f"y{i+1}",
                    x=(x0_bar + x1_bar) / 2, # Center of the bar
                    y=accuracy_value + 2, # Slightly above the bar
                    text=f'{accuracy_value:.0f}%',
                    showarrow=False,
                    font=dict(color='black', size=11),
                    row=1, col=i+1
                )

# --- 4. CUSTOMIZATION ---

fig.update_layout(
    title_text='Accuracy Measurements by Sub Test Case and Metric, Grouped by Tc',
    title_x=0.0,
    title_font_size=20,
    paper_bgcolor='white',
    plot_bgcolor='rgba(255,255,255,0)',
    height=500,
    
    # Legend styling
    legend=dict(
        orientation="h",
        yanchor="middle",
        y=1.02,
        xanchor="right",
        x=1.0,
        bgcolor='rgba(255,255,255,0.8)',
        bordercolor='rgba(0,0,0,0)',
        borderwidth=0
    ),
    
    # Adjust bar gaps (these will still influence the *invisible* bars for scaling)
    bargap=0.3,      
    bargroupgap=0.1, 
)

# Customize each subplot's axes
for i in range(num_tc):
    # X-axis for each subplot
    fig.update_xaxes(
        row=1, col=i+1,
        showgrid=False,
        showline=False, # We draw a line below manually with a shape if needed
        tickfont=dict(size=12, color='black'),
        title_text='',
        fixedrange=True,
        tickangle=-45, # Apply to all x-axes
    )
    # Y-axis for each subplot
    fig.update_yaxes(
        row=1, col=i+1,
        showgrid=True,
        gridcolor='rgba(150, 150, 150, 0.5)',
        gridwidth=0.5,
        showline=False,
        showticklabels=False,
        ticks='',
        zeroline=False,
        range=[0, df_long['Accuracy'].max() * 1.2]
    )

# Clean up subplot titles if make_subplots added its own 'title_text'
for i, title in enumerate(fig.layout.annotations):
    if title.text.startswith("Tc="): # If make_subplots created default titles
        title.text = title.text.split("=")[-1]
    title.x = (i / num_tc) + (0.5 / num_tc) # Center subplot titles

fig.show()
