import torch
import numpy as np

def investigate_outliers(x, sample_size=500000):
    """
    Deep dive into extreme values to understand the data distribution.
    """
    print("=" * 80)
    print("OUTLIER INVESTIGATION")
    print("=" * 80)
    
    n_rows, n_features = x.shape
    print(f"\nShape: {x.shape}")
    
    # Sample for analysis
    if n_rows > sample_size:
        indices = torch.randperm(n_rows)[:sample_size]
        x_sample = x[indices]
        print(f"Using sample of {sample_size:,} rows")
    else:
        x_sample = x
    
    # Convert to float64 for better precision
    if x.dtype != torch.float64:
        x = x.double()
        x_sample = x_sample.double()
    
    print("\n" + "=" * 80)
    print("EXTREME VALUE ANALYSIS")
    print("=" * 80)
    
    for i in range(n_features):
        feat = x[:, i]
        feat_sample = x_sample[:, i]
        
        # Remove zeros for non-zero analysis
        feat_nonzero = feat[feat != 0]
        
        print(f"\n--- Feature {i} ---")
        print(f"  Total values: {len(feat):,}")
        print(f"  Zeros: {(feat == 0).sum().item():,} ({100*(feat == 0).sum().item()/len(feat):.2f}%)")
        print(f"  Non-zero values: {len(feat_nonzero):,}")
        
        if len(feat_nonzero) > 0:
            min_nz = feat_nonzero.min().item()
            max_nz = feat_nonzero.max().item()
            mean_nz = feat_nonzero.mean().item()
            median_nz = feat_nonzero.median().item()
            
            print(f"\n  Non-zero stats:")
            print(f"    Min: {min_nz:.6e}")
            print(f"    Max: {max_nz:.6e}")
            print(f"    Mean: {mean_nz:.6e}")
            print(f"    Median: {median_nz:.6e}")
            
            # Percentiles on sample (non-zero only)
            feat_nz_sample = feat_sample[feat_sample != 0]
            if len(feat_nz_sample) > 0:
                feat_np = feat_nz_sample.cpu().numpy()
                
                percentiles = [50, 75, 90, 95, 99, 99.9, 99.99, 100]
                print(f"\n  Percentiles (non-zero):")
                for p in percentiles:
                    val = np.percentile(feat_np, p)
                    print(f"    {p:>6.2f}%: {val:.6e}")
                
                # Count extreme values
                thresholds = [1e10, 1e50, 1e100, 1e200, 1e300]
                print(f"\n  Values exceeding thresholds:")
                for thresh in thresholds:
                    count = (feat_nonzero > thresh).sum().item()
                    if count > 0:
                        pct = 100 * count / len(feat_nonzero)
                        print(f"    > {thresh:.0e}: {count:,} ({pct:.4f}%)")
                
                # Check if values look like they might be corrupted
                if max_nz > 1e100:
                    print(f"\n  ⚠️  EXTREMELY LARGE VALUES DETECTED!")
                    print(f"      Max value {max_nz:.2e} suggests possible:")
                    print(f"      - Data corruption")
                    print(f"      - Overflow during computation")
                    print(f"      - Missing value encoding gone wrong")
                    print(f"      - Need for log transformation")
        else:
            print(f"  All zeros!")
    
    # Overall recommendations
    print("\n" + "=" * 80)
    print("DIAGNOSTIC QUESTIONS")
    print("=" * 80)
    print("\n1. Are these extremely large values (1e+304) expected in your data?")
    print("   - If NO: They might be corrupted/missing value indicators")
    print("   - If YES: You likely need log transformation or clipping")
    print("\n2. What does this data represent?")
    print("   - Counts/frequencies? → Log transform + StandardScaler")
    print("   - Measurements? → Check if large values are errors")
    print("   - Already transformed? → May need to undo transformation")
    print("\n3. Can you tolerate removing/clipping extreme outliers?")
    print("   - Option A: Clip at 99.9th percentile")
    print("   - Option B: Log transform (log(x + 1) for zeros)")
    print("   - Option C: Robust scaling (ignore outliers)")
    
    return None

# Run this
print("Run: investigate_outliers(x)")
print("\nThen answer the diagnostic questions above!")
