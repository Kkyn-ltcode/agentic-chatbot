// Handle sending message and streaming response
  const handleSendMessage = async () => {
    if (inputText.trim() === '') return;

    const userMessage = { sender: 'user', text: inputText.trim() };
    // Add user message immediately
    setMessages((prevMessages) => [...prevMessages, userMessage]);

    // Add an empty bot message placeholder for streaming
    const initialBotMessage = { sender: 'bot', text: '' };
    setMessages((prevMessages) => [...prevMessages, initialBotMessage]);

    setInputText(''); // Clear input immediately

    setIsLoading(true); // Start loading indicator

    const backendSessionId = currentConversationId || userId; // Use currentConversationId or userId for session

    // Define the callback for each chunk received
    const appendChunk = (chunk) => {
      setMessages((prevMessages) => {
        const lastMessageIndex = prevMessages.length - 1;
        // Ensure the last message is from the bot before appending
        if (lastMessageIndex >= 0 && prevMessages[lastMessageIndex].sender === 'bot') {
          const updatedMessages = [...prevMessages];
          updatedMessages[lastMessageIndex] = {
            ...updatedMessages[lastMessageIndex],
            text: updatedMessages[lastMessageIndex].text + chunk,
          };
          return updatedMessages;
        }
        return prevMessages; // Should not happen if logic is correct
      });
    };

    try {
      // Call the streaming function
      await callFastAPIChatbot(userMessage.text, backendSessionId, appendChunk);
    } catch (error) {
      console.error("Error during streaming:", error);
      // Append an error message to the bot's last message if streaming fails
      setMessages((prevMessages) => {
        const lastMessageIndex = prevMessages.length - 1;
        if (lastMessageIndex >= 0 && prevMessages[lastMessageIndex].sender === 'bot') {
          const updatedMessages = [...prevMessages];
          updatedMessages[lastMessageIndex] = {
            ...updatedMessages[lastMessageIndex],
            text: updatedMessages[lastMessageIndex].text + `\n\n(Error: Failed to get full response. ${error.message})`,
          };
          return updatedMessages;
        }
        return prevMessages;
      });
    } finally {
      setIsLoading(false); // Stop loading indicator after streaming completes or errors
      // Save conversation after streaming is done and messages are fully updated
      // This will capture the full streamed response
      if (currentConversationId) {
        const latestMessages = messages; // `messages` might be stale here due to closure,
                                       // consider passing a snapshot or re-reading from state if needed for saving
        await saveConversation(currentConversationId, currentConversationTitle, latestMessages);
      }
    }
  };
