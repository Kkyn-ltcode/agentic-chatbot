// Handle sending message and streaming response
  const handleSendMessage = async () => {
    if (inputText.trim() === '') return;

    const userMessage = { sender: 'user', text: inputText.trim() };
    // Add user message immediately
    setMessages((prevMessages) => [...prevMessages, userMessage]);

    // Add an empty bot message placeholder for streaming
    const initialBotMessage = { sender: 'bot', text: '' };
    setMessages((prevMessages) => [...prevMessages, initialBotMessage]);

    setInputText(''); // Clear input immediately

    setIsLoading(true); // Start loading indicator

    // Ensure backendSessionId is always a string, even if userId is null/undefined
    const backendSessionId = currentConversationId || currentUserId || "default_session_frontend"; // <--- Updated fallback for sessionId
    console.log("Sending sessionId to backend:", backendSessionId); // Debug log

    // Define the callback for each chunk received
    const appendChunk = (chunk) => {
      console.log("appendChunk: Received chunk =", chunk); // Debug log

      setMessages((prevMessages) => {
        const lastMessageIndex = prevMessages.length - 1;
        // Ensure the last message is from the bot before appending
        if (lastMessageIndex >= 0 && prevMessages[lastMessageIndex].sender === 'bot') {
          const updatedMessages = [...prevMessages];
          const oldText = updatedMessages[lastMessageIndex].text;
          const newText = oldText + chunk;
          updatedMessages[lastMessageIndex] = {
            ...updatedMessages[lastMessageIndex],
            text: newText,
          };
          console.log("appendChunk: Updating message text from", oldText, "to", newText); // Debug log
          return updatedMessages;
        }
        console.warn("appendChunk: Last message is not bot message or no messages exist."); // Debug warn
        return prevMessages;
      });
    };

    try {
      // Call the streaming function
      await callFastAPIChatbot(userMessage.text, backendSessionId, appendChunk);
    } catch (error) {
      console.error("Error during streaming:", error);
      // Append an error message to the bot's last message if streaming fails
      setMessages((prevMessages) => {
        const lastMessageIndex = prevMessages.length - 1;
        if (lastMessageIndex >= 0 && prevMessages[lastMessageIndex].sender === 'bot') {
          const updatedMessages = [...prevMessages];
          updatedMessages[lastMessageIndex] = {
            ...updatedMessages[lastMessageIndex],
            text: updatedMessages[lastMessageIndex].text + `\n\n(Error: Failed to get full response. ${error.message})`,
          };
          return updatedMessages;
        }
        return prevMessages;
      });
    } finally {
      setIsLoading(false); // Stop loading indicator after streaming completes or errors
      // Save conversation after streaming is done and messages are fully updated
      // Use a functional update for saveConversation to get the latest messages
      setMessages(finalMessages => { // Use finalMessages from state closure
        if (currentConversationId) {
          saveConversation(currentConversationId, currentConversationTitle, finalMessages);
        } else {
          // If new conversation, generate a new ID and save
          const newConvId = doc(collection(db, `artifacts/${appId}/users/${currentUserId}/conversations`)).id;
          const defaultTitle = finalMessages[0]?.text.substring(0, 50) || "New Chat";
          saveConversation(newConvId, defaultTitle, finalMessages);
          setCurrentConversationId(newConvId);
          setCurrentConversationTitle(defaultTitle);
        }
        return finalMessages; // Return the messages as is
      });
    }
  };
